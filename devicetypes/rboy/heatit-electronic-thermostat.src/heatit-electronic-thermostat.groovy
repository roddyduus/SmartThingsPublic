/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "02.02.01"
}

/*
 * Electronic Electronic Thermostat with Heat, Cool and Heat Eco Mode
 *
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 *
 * Change log:
 * 2021-12-22 - (v02.02.01) Added Energy Reset button for future firmware updates
 * 2020-12-01 - (v02.01.05) Improve setpoint reliability by giving time to change setpoints
 * 2020-11-12 - (v02.01.03) Z-TRM3 reduce status looping, clean up code
 * 2020-10-21 - (v02.01.01) Clean up
 * 2020-10-20 - (v02.01.00) Fix for Z-TRM3 not accepting heating setopint below 13C
 * 2020-10-02 - (v02.00.00) New ST app VID's, fix thermostat display settings not working for ZTRM3
 * 2020-09-01 - (v01.02.01) Update for new ST app UI
 * 2020-06-29 - (v01.02.00) Added support to adjust meter reporting delta value and limit unsupported values
 * 2020-06-01 - (v01.01.01) Update the internal naming convention
 * 2020-03-23 - (v01.01.00) Added support for HeatIt Z-TRM3
 * 2020-02-27 - (v01.00.10) Handle multiple hub installations betters
 * 2020-01-31 - (v01.00.09) Limit configuration to Z-TRM2fx only to avoid conflict with older model
 * 2020-01-30 - (v01.00.08) Disable polling due to hardware load limitations
 * 2019-11-23 - (v01.00.07) Report setpoints range for new app
 * 2019-11-21 - (v01.00.06) Make reporting configurable, adjust defaults to reduce traffic
 * 2019-11-12 - (v01.00.04) Clean up code, update class versions
 * 2019-09-05 - (v01.00.03) Show Auto for fan mode in new app
 * 2019-08-27 - (v01.00.02) Updated MCD to show temperature from sensors in new ST app
 * 2019-08-17 - (v01.00.01) Update text in preference, add MCD for new app
 * 2019-06-01 - (v01.00.00) Initial release
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *
*/

metadata {
    definition (name: "Heatit Electronic Thermostat", namespace: "rboy", author: "RBoy Apps", ocfDeviceType: "oic.d.thermostat", vid: "SmartThings-smartthings-Rboy_Test", mnmn: "SmartThings", mcdSync: true) {
		capability "Actuator"
		capability "Sensor"
		capability "Temperature Measurement"
		capability "Thermostat"
        capability "Thermostat Cooling Setpoint"
        capability "Thermostat Heating Setpoint"
        capability "Thermostat Fan Mode"
        capability "Thermostat Mode"
        capability "Thermostat Operating State"
		capability "Energy Meter"
		capability "Power Meter"
        capability "Voltage Measurement"
		capability "Refresh"
		capability "Health Check"
        capability "Configuration"
        capability "rboyapps.energyReset"
        capability "rboyapps.ztrmSensor"
        capability "rboyapps.ztrmDisplay"
        capability "rboyapps.versioning"

        ///attribute "codeVersion", "string"
        ///attribute "dhName", "string"
        ///attribute "displayMode", "string"
        ///attribute "sensorMode", "string"
        attribute "minTemp", "number"
        attribute "maxTemp", "number"
        attribute "thermStatus", "string"

        ///command "toggleDisplayMode"
        ///command "setDisplayMode", "string"
        ///command "setDisplaySetpoint"
        ///command "setDisplayTemperature"
        command "switchMode"
        command "raiseHeatingSetpoint"
        command "lowerHeatingSetpoint"
        command "raiseCoolSetpoint"
        command "lowerCoolSetpoint"
        command "levelUpDown"
        command "levelUp"
        command "levelDown"
        command "quickSetCool"
        command "quickSetHeat"

        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"0806", mfr:"019B", prod:"0003", model:"0203", deviceJoinName:"Heatit Z-TRM3", vid: "3fe6000b-a9c2-32b4-96d8-be5f4877bf8c", mnmn: "SmartThingsCommunity" // zw:L type:0806 mfr:019B prod:0003 model:0203 ver:4.00 zwv:6.07 lib:03 cc:5E,85,59,8E,60,55,86,72,5A,73,98,6C,70,7A,43,40,42,32 role:05 ff:9200 ui:9201 epc:4
        fingerprint type:"0806", mfr:"019B", prod:"0003", model:"0202", deviceJoinName:"Heatit Z-TRM2fx", vid: "5c7e8215-9177-3cff-8603-f74eecc7d29b", mnmn: "SmartThingsCommunity" // zw:Ls, type:0806, mfr:019B, prod:0003, model:0202, ver:3.04, zwv:5.03, lib:03, cc:[5E, 55, 6C, 98, 9F], sec:[86, 85, 8E, 59, 60, 72, 5A, 73, 70, 7A, 43, 40, 32], role:05, ff:9200, ui:9201, epc:4, endpointCount:4, endpointInfo:[] // zw:Ls type:0806 mfr:019B prod:0003 model:0202 ver:3.06 zwv:5.03 lib:03 cc:5E,55,6C,98,9F sec:86,85,8E,59,60,72,5A,73,70,7A,43,40,32 role:05 ff:9200 ui:9201 epc:4
        fingerprint type:"0806", mfr:"019B", prod:"0001", model:"0001", deviceJoinName:"Heatit Z-TRM2", vid: "45ce2ea0-05ea-3f96-90b2-9fa04992eac1", mnmn: "SmartThingsCommunity" // type:0806 mfr:019B prod:0001 model:0001 ver:1.08 zwv:3.83 lib:06 cc:5E,43,31,86,40,59,85,73,72,5A,32,70 role:05 ff:9200 ui:9200

    }

    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "thermostat", width: 6, height: 4){
            tileAttribute ("device.temperature", key: "PRIMARY_CONTROL") {
                attributeState("temperature", label:'${currentValue}°', defaultState: true)
            }
            tileAttribute ("device.thermStatus", key: "SECONDARY_CONTROL") {
                attributeState("thermStatus", label:'${currentValue}', icon: "st.Weather.weather2", defaultState: true)
            }
            tileAttribute ("device.level", key: "VALUE_CONTROL") {
                attributeState("default", action: "levelUpDown")
                attributeState("VALUE_UP", action: "levelUp")
                attributeState("VALUE_DOWN", action: "levelDown")
            }
            tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
                attributeState("idle", backgroundColor:"#cccccc")
                attributeState("heating", backgroundColor:"#e86d13")
                attributeState("cooling", backgroundColor:"#00A0DC")
            }
            /*tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") {
                attributeState("off", label:'${name}')
                attributeState("heat", label:'${name}')
                attributeState("cool", label:'${name}')
                attributeState("auto", label:'${name}')
                attributeState("emergency heat", label:'${name}')
                attributeState("eco", label:'${name}')
            }
            tileAttribute("device.heatingSetpoint", key: "HEATING_SETPOINT") {
                attributeState("heatingSetpoint", label:'${currentValue}', defaultState: true)
            }
            tileAttribute("device.coolingSetpoint", key: "COOLING_SETPOINT") {
                attributeState("coolingSetpoint", label:'${currentValue}', defaultState: true)
            }*/
        }
        valueTile("temperature", "device.temperature", width: 4, height: 4) {
            state("temperature", label:'${currentValue}°',
                  backgroundColors:[
							// Celsius
							[value: 0, color: "#153591"],
							[value: 7, color: "#1e9cbb"],
							[value: 15, color: "#90d2a7"],
							[value: 23, color: "#44b621"],
							[value: 28, color: "#f1d801"],
							[value: 35, color: "#d04e00"],
							[value: 37, color: "#bc2323"],
							// Fahrenheit
							[value: 40, color: "#153591"],
							[value: 44, color: "#1e9cbb"],
							[value: 59, color: "#90d2a7"],
							[value: 74, color: "#44b621"],
							[value: 84, color: "#f1d801"],
							[value: 95, color: "#d04e00"],
							[value: 96, color: "#bc2323"]
					]
                 )
        }
        standardTile("mode", "device.thermostatMode", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false, decoration: "flat") {
            state "off", action:"switchMode", nextState:"...", icon: "st.thermostat.heating-cooling-off"
            state "heat", action:"switchMode", nextState:"...", icon: "st.thermostat.heat", backgroundColor: '#e86d13'
            state "cool", action:"switchMode", nextState:"...", icon: "st.thermostat.cool", backgroundColor: '#00a0dc'
            state "auto", action:"switchMode", nextState:"...", icon: "st.thermostat.auto"
            state "emergency heat", action:"switchMode", nextState:"...", icon: "st.thermostat.emergency-heat", backgroundColor: '#E11102'
            state "eco", label: 'eco', action:"switchMode", nextState:"...", icon: "https://s3.amazonaws.com/smartapp-icons/GreenLiving/Cat-GreenLiving.png", backgroundColor: '#e86d13'
            state "...", label: "...", nextState:"..."
        }
        standardTile("displayMode", "device.displayMode", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false, decoration: "flat") {
            state "setpoint", label: 'Display', action:"toggleDisplayMode", nextState:"...", icon: "https://www.rboyapps.com/images/SetpointDTH.png", defaultState: true
            state "temperature", label: 'Display', action:"toggleDisplayMode", nextState:"...", icon: "https://www.rboyapps.com/images/TemperatureDTH.png"
            state "...", label: "...", nextState:"..."
        }
        controlTile("heatSliderControl", "device.heatingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
            state "heat", action:"setHeatingSetpoint", backgroundColor:"#e86d13"
        }
        standardTile("heatingSetpoint", "device.heatingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "heat", label:'${currentValue}°', backgroundColor: '#e86d13'
        }
        controlTile("coolSliderControl", "device.coolingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
            state "cool", action:"setCoolingSetpoint", backgroundColor: "#00a0dc"
        }
        standardTile("coolingSetpoint", "device.coolingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "cool", label:'${currentValue}°', backgroundColor: '#00a0dc'
        }
        standardTile("refresh", "command.refresh", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "default", action:"refresh.refresh", icon:"st.secondary.refresh"
        }
        standardTile("configure", "device.configure", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "configure", label:'', action:"configuration.configure", icon:"st.secondary.configure"
        }
        standardTile("raiseHeatingSetpoint", "device.raiseHeatingSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "raiseHeatingSetpoint", label:'Heat', action:"raiseHeatingSetpoint", icon:"st.thermostat.thermostat-up"
        }
        standardTile("lowerHeatingSetpoint", "device.lowerHeatingSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "lowerHeatingSetpoint", label:'Heat', action:"lowerHeatingSetpoint", icon:"st.thermostat.thermostat-down"
        }
        standardTile("raiseCoolSetpoint", "device.raiseCoolSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "raiseCoolSetpoint", label:'Cool', action:"raiseCoolSetpoint", icon:"st.thermostat.thermostat-up"
        }
        standardTile("lowerCoolSetpoint", "device.lowerCoolSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "lowerCoolSetpoint", label:'Cool', action:"lowerCoolSetpoint", icon:"st.thermostat.thermostat-down"
        }
		valueTile("power", "device.power", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} W'
		}
        valueTile("energy", "device.energy", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} kWh', action:"resetEnergy"
		}
		valueTile("voltage", "device.voltage", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} V'
		}		
        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }

        childDeviceTiles("outlets") // Don't render all at one go, customize them
        //childDeviceTile([childTileName: "temperature"], "internalsensor", "InternalSensor")
        //childDeviceTile([childTileName: "temperature"], "floorsensor", "FloorSensor")
        //childDeviceTile([childTileName: "temperature"], "roomsensor", "RoomSensor")

        main "summary"
        details(["summary", "mode", "displayMode", "refresh", "heatingSetpoint", "lowerHeatingSetpoint", "raiseHeatingSetpoint", "heatSliderControl", "coolingSetpoint", "lowerCoolSetpoint", "raiseCoolSetpoint", "coolSliderControl", "power", "energy", "voltage", "outlets", "internalsensor", "floorsensor", "roomsensor"])
    }
}

preferences {
    section() {
        input title: "", description: "Heatit Electronic Thermostat Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    }

    section() {
        input title: "", description: "", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "sensorSelector", "enum", title: "Temperature sensor", description: "default", multiple: false, options: getTempSensorModes(), required: false, displayDuringSetup: false
        input "fCal", "decimal", title: "Floor sensor correction", description: "Adjust calibration °C", defaultValue: "0.0", range: "-4.0..4.0", required: false, displayDuringSetup: false
        input "aCal", "decimal", title: "Room sensor correction", description: "Adjust calibration °C", defaultValue: "0.0", range: "-4.0..4.0", required: false, displayDuringSetup: false
        input "swingDiff", "decimal", title: "Temperature swing", description: "Select hysteresis in °C", defaultValue: "0.5", range: "0.3..3.0", required: false, displayDuringSetup: false
        input "fLo", "decimal", title: "Min floor temperature", description: "Temperature limit in °C", defaultValue: "5.0", range: "5.0..40.0", required: false, displayDuringSetup: false
        input "fHi", "decimal", title: "Max floor temperature", description: "Temperature limit in °C", defaultValue: "40.0", range: "5.0..40.0", required: false, displayDuringSetup: false
        input "aLo", "decimal", title: "Min room temperature", description: "Temperature limit in °C", defaultValue: "5.0", range: "5.0..40.0", required: false, displayDuringSetup: false
        input "aHi", "decimal", title: "Max room temperature", description: "Temperature limit in °C", defaultValue: "40.0", range: "5.0..40.0", required: false, displayDuringSetup: false
        input "dimmedButtons", "number", title: "Buttons brightness (dimmed)", description: "0% to 100%", defaultValue: "50", range: "0..100", required: false, displayDuringSetup: false
        input "activeButtons", "number", title: "Buttons brightness (active)", description: "0% to 100%", defaultValue: "100", range: "0..100", required: false, displayDuringSetup: false
        input "dimmedDisplay", "number", title: "Display brightness (dimmed)", description: "0% to 100%", defaultValue: "50", range: "0..100", required: false, displayDuringSetup: false
        input "activeDisplay", "number", title: "Display brightness (active)", description: "0% to 100%", defaultValue: "100", range: "0..100", required: false, displayDuringSetup: false

        input "tempHysteresis", "decimal", title: "Temperature reporting sensitivity", description: "default (°C)", range: "0.1..10.0", required: false, displayDuringSetup: false

        input title: "", description: "Adjust sensor reporting frequency (in seconds, 0 to disable)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "meterReporting", "number", title: "Metering sensors", description: "default", range: "0..32767", required: false, displayDuringSetup: false
        input "tempReporting", "number", title: "Temperature sensors", description: "default", range: "0..32767", required: false, displayDuringSetup: false

        input title: "", description: "Adjust sensor reporting sensitivity (in kWh, 0 to disable)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "meterSensitivity", "number", title: "Metering senstivity", description: "default", range: "0..255", required: false, displayDuringSetup: false
    }
}

private getThermostatSwitchEp() { 4 } // Thermostat binary switch endpoint
private getInternalSensorEp() { 2 } // Internal sensor endpoint
private getRoomSensorEp() { isHeatItZTRM3() ? 3 : 2 } // External room sensor endpoint
private getFloorSensorEp() { isHeatItZTRM3() ? 4 : 3 } // Floor sensor endpoint
private getTempSensorModes() { ["0":"Floor sensor","1":"Internal sensor","2":"Internal sensor + floor limitation","3":"External sensor (room)","4":"External sensor + floor limitation"] }
private getMIN_HEATING_C() { 5 }
private getMAX_HEATING_C() { 40 }
private getMIN_COOLING_C() { 5 }
private getMAX_COOLING_C() { 40 }

import groovy.transform.Field

@Field final int RESET_DELAY = 2

// Sent delayed event
def delayedEvent(data) {
    log.trace "Sending delayed event: $data"
    sendEvent(data)
}

def uninstalled() {
    log.trace "Uninstalled called"
}

def installed() {
    log.trace "Installed called"
	runIn(0, initialize, [overwrite: true])  // Allow configure command to be sent and acknowledged before proceeding
}

def updated() {
    log.trace "Updated called"
	// If not set update ManufacturerSpecific data
    runIn(0, initialize, [overwrite: true])  // Updated is called twice when preferences are updated
}

def initialize() {
    createChildDevices() // Create child devices if required
    
    // For the new app, only show auto mode
    sendEvent(name: "supportedThermostatFanModes", value: ["auto"], displayed: false)
    sendEvent(name: "thermostatFanMode", data:[supportedThermostatFanModes: ["auto"]], value: "auto", displayed: false)
    
	// Device-Watch simply pings if no device events received for 12 hours (checkInterval)
	sendEvent(name: "checkInterval", value: 12 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
	sendHubCommand(response(configure()).toHubAction()) // Send command since this can be called from a schedule
}

/**
 * PING is used by Device-Watch in attempt to reach the Device
 * */
def ping() {
	log.debug "ping() called"
	// Just get Operating State as it is not reported when it changes and there's no need to flood more commands
	sendHubCommand(new physicalgraph.device.HubAction(secure((isHeatItZTRM2fx() || isHeatItZTRM2()) ? encap(zwave.switchBinaryV1.switchBinaryGet(), thermostatSwitchEp) : zwave.thermostatOperatingStateV1.thermostatOperatingStateGet())))
}

def parse(String description) {
	def result = []
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Heatit Z-TRM2fx Device Handler"]) // Save DH Name for parent app
	if (description.startsWith("Err 106")) {
        log.warn("Z-Wave error '$description'")
		state.sec = 0
		result += createEvent(descriptionText: description, isStateChange: true)
	} else if (description != "updated") {
		def zwcmd = zwave.parse(description, commandClassCapabilities)
		if (zwcmd) {
			result += zwaveEvent(zwcmd)
            if (result) {
                log.trace "Parse returned $result"
            }
		} else {
			log.warn "$device.displayName couldn't parse $description"
		}
	}

    def thermStatusS = ""
    switch (device.currentValue('sensorMode')) {
        case "internal":
        	thermStatusS = "Internal sensor"
            break
        case "iboth": // iboth uses internal room sensor with a cutoff limited by floor sensor
        	thermStatusS = "Internal / Floor"
            break
        case "floor":
        	thermStatusS = "Floor sensor"
            break
        case "room":
        	thermStatusS = "Room sensor"
            break
        case "both": // both uses external room sensor with a cutoff limited by floor sensor
        	thermStatusS = "Room / Floor"
            break
        case null: // not initialized yet, ignore
        	break
        default:
            log.error "Unknown sensor mode ${device.currentValue('sensorMode')}"
            break
    }
    //log.trace thermStatusS
    sendEvent(name: "thermStatus", value: thermStatusS, displayed: false) // Return the status

    return result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
    log.warn "SecurityMessageEncapsulation $cmd"
	def encapsulatedCommand = cmd.encapsulatedCommand(commandClassCapabilities)
	if (encapsulatedCommand) {
        state.sec = 1
		zwaveEvent(encapsulatedCommand)
	}
}

def zwaveEvent(physicalgraph.zwave.commands.multichannelv3.MultiChannelCmdEncap cmd) {
	//log.trace cmd
    // TODO: Patch for Supervision Class when using S2 Authenication if ST doesn't fix it (when ST handles it, this will be parsed by the platform and won't reach the DTH so this becomes redundant)
    if (cmd.commandClass == 108) {
        cmd.parameter = cmd.parameter.drop(2)
        cmd.commandClass = cmd.parameter[0]
        cmd.command = cmd.parameter[1]
        cmd.parameter = cmd.parameter.drop(2)
        log.debug "UPDATING: $cmd"
    }
	def encapsulatedCommand = cmd.encapsulatedCommand(commandClassCapabilities)
	if (encapsulatedCommand) {
		zwaveEvent(encapsulatedCommand, cmd.sourceEndPoint as Integer)
	} else {
        log.warn "multichannelv3.MultiChannelCmdEncap: unrecognized command $cmd"
    }
}

private secure(physicalgraph.zwave.Command cmd) {
    //log.trace cmd
    //log.trace "Secure: $state.sec"
	if (state.sec) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private secureSequence(commands, delay=300) { // Some of these params need more time to get on this switch or they are dropped
	delayBetween(commands.collect{ secure(it) }, delay)
}

// Multi channel encapsulation of a command with a target endpoint and an optional bitmask addressing
private encap(cmd, ep, bitMask = false) {
    zwave.multiChannelV3.multiChannelCmdEncap(bitAddress: bitMask, destinationEndPoint: ep).encapsulate(cmd)
}

// Event Generation
def zwaveEvent(physicalgraph.zwave.commands.thermostatsetpointv2.ThermostatSetpointReport cmd, ep = null) {
    log.trace "$ep: $cmd"

    def cmdScale = cmd.scale == 1 ? "F" : "C"
	def setpoint = getTempInLocalScale(cmd.scaledValue, cmdScale)
	def unit = getTemperatureScale()
	switch (cmd.setpointType) {
    	case 0: // Sent by TRM3 when requesting COOLING setpoint, ignore
        	return;
		case 1:
        case 11: // Eco heat
			sendEvent(name: "heatingSetpoint", value: setpoint, unit: unit, displayed: false)
			updateThermostatSetpoint("heatingSetpoint", setpoint)
			break;
		case 2:
			sendEvent(name: "coolingSetpoint", value: setpoint, unit: unit, displayed: false)
			updateThermostatSetpoint("coolingSetpoint", setpoint)
			break;
		default:
			log.warn "unknown setpointType $cmd.setpointType"
			return
	}
	// So we can respond with same format
	state.size = cmd.size
	state.scale = cmd.scale
	state.precision = cmd.precision
	// Make sure return value is not result from above expresion
	return []
}

def zwaveEvent(physicalgraph.zwave.commands.sensormultilevelv5.SensorMultilevelReport cmd, ep = null) {
    log.trace "$ep: $cmd"

	def map = [:]
	if (cmd.sensorType == 1) {
        map.value = convertTemperatureIfNeeded(cmd.scaledSensorValue?.toBigDecimal(), cmd.scale == 1 ? "F" : "C")?.toDouble()?.round(cmd.precision ? 1 : 0) // Keep upto one decimal point for compatibility with newer thermostats with improved precision reporting
		map.unit = getTemperatureScale()
		map.name = "temperature"
		updateThermostatSetpoint(null, null)
	}
    
    // Update the appropriate child device
    def childDevice = childDevices?.find { it.deviceNetworkId.endsWith("$ep") }
    if (childDevice) {
        childDevice.sendEvent(map)
    } else {
        log.error "Cannot find child device for Endpoint $ep: $cmd"
    }

    switch (ep) { // Match the current sensor mode with the sensor being reported
        case floorSensorEp:
            if (device.currentValue("sensorMode") == "floor") {
                return createEvent(map)
            }
            break
        case roomSensorEp:
            if ((device.currentValue("sensorMode") == "room") || (device.currentValue("sensorMode") == "both")) {
                return createEvent(map)
            }
            break
        case internalSensorEp:
            if ((device.currentValue("sensorMode") == "internal") || (device.currentValue("sensorMode") == "iboth")) {
                return createEvent(map)
            }
            break
        default:
            log.warn "Unknown endpoint sensor $ep: $cmd"
            break
    }
    
    []
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport cmd, ep = null) {
    log.trace "$ep: $cmd"

	def map = [name: "thermostatMode", data:[supportedThermostatModes: state.supportedModes]]
	switch (cmd.mode) {
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_OFF:
			map.value = "off"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_HEAT:
			map.value = "heat"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUXILIARY_HEAT:
			map.value = "emergency heat"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_COOL:
			map.value = "cool"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUTO:
			map.value = "auto"
			break
        case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_ENERGY_SAVE_HEAT:
            map.value = "eco"
            break
	}
	sendEvent(map)
	updateThermostatSetpoint(null, null)
    
    // Get updated heating/eco setpoints and operating state when switching modes for heatIt
    if (isHeatItZTRM2fx() || isHeatItZTRM2()) { // Don't do operatingStateGet otherwise it'll go into a loop
        def cmds = []
        cmds << secureSequence([
            encap(zwave.switchBinaryV1.switchBinaryGet(), thermostatSwitchEp), // HeatIt - 4th endpoint is relay (operating state) - don't use basicGet since HeatIt has a bug where it spuriously sends a BasicReport (255) even when it's not operating
            zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: (device.currentValue("thermostatMode") == "eco" ? 11 : 1)), // HEAT, if we're in eco mode then read from settings
            zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 2) // COOL
        ].flatten(), 2300)
        sendHubCommand(response(cmds).toHubAction()) // Send command
    }
    []
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport cmd, ep = null) {
    log.trace "$ep: $cmd"

	def map = [name: "thermostatOperatingState"]
	switch (cmd.operatingState) {
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_IDLE:
			map.value = "idle"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_HEATING:
			map.value = "heating"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_COOLING:
			map.value = "cooling"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_FAN_ONLY:
			map.value = "fan only"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_HEAT:
			map.value = "pending heat"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_COOL:
			map.value = "pending cool"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_VENT_ECONOMIZER:
			map.value = "vent economizer"
			break
	}
	// Makes sure we have the correct thermostat mode
	sendHubCommand(new physicalgraph.device.HubAction(secure(zwave.thermostatModeV2.thermostatModeGet())))
	sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeSupportedReport cmd, ep = null) {
    log.trace "$ep: $cmd"

	def supportedModes = []

	if(cmd.heat) { supportedModes << "heat" }
	if(cmd.cool) { supportedModes << "cool" }
	// Make sure off is before auto, this ensures the right setpoint is used based on current temperature when auto is set
	if(cmd.off) { supportedModes << "off" }
	if(cmd.auto) { supportedModes << "auto" }
	if(cmd.auxiliaryemergencyHeat) { supportedModes << "emergency heat" }
    if(cmd.energySaveHeat) { supportedModes << "eco" } // Report energy save heat as eco mode

	state.supportedModes = supportedModes
	createEvent(name: "supportedThermostatModes", value: supportedModes, displayed: false)
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd, ep = null) {
    log.trace "$ep: $cmd"

    def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
    log.debug "msr: $msr"
    updateDataValue("MSR", msr)
    []
}

private setOperatingState(cmd) {
    def map =[:]
    if (cmd.value) {
        // Relay on
        switch (device.currentValue("thermostatMode")) {
            case "eco": // HeatIt ECO mode is for eco heating
            case "emergency heat":
            case "heat":
            	map = [ name: "thermostatOperatingState", value: "heating" ]
                break
            case "cool":
            	map = [ name: "thermostatOperatingState", value: "cooling" ]
                break
            case "off":
            	map = [ name: "thermostatOperatingState", value: "idle" ]
            	break    
            default:
            	log.warn "Unsupported thermostat operating state: ${device.currentValue("thermostatMode")}"
                break
        }                
    } else {
    	// Relay off
        map = [ name: "thermostatOperatingState", value: "idle" ]
    }
    
    createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd, ep = null) {
    if (isHeatIt() && !ep) { // HeatIt sends a suprious non encapsulated BasicReport with value 255, ignore it - all exepected communications should come through multi channell endpoints only
        log.warn "IGNORING SPURIOUS BASIC_REPORT from endpoint $ep: $cmd"
        []
    } else {
        log.trace "$ep: $cmd"
        setOperatingState(cmd)
    }
}

def zwaveEvent(physicalgraph.zwave.commands.switchbinaryv1.SwitchBinaryReport cmd, ep = null) {
	log.trace "$ep: $cmd"
    setOperatingState(cmd)
}

def zwaveEvent(physicalgraph.zwave.commands.meterv3.MeterReport cmd, ep = null) {
    log.trace "$ep: MeterReport: $cmd"
    
    def result = []
    
	if (cmd.scale == 0) {
		result << createEvent(name: "energy", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "kWh")
	} else if (cmd.scale == 1) {
		result << createEvent(name: "energykVAh", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "kVAh")
	} else if (cmd.scale == 2) {
		result << createEvent(name: "power", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "W")
	} else if (cmd.scale == 4) {
		result << createEvent(name: "voltage", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "V")
	} else if (cmd.scale == 5) {
		result << createEvent(name: "amperage", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "A")
	} else {
        log.warn "Unknown Meter Report: $cmd"
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd, ep = null) {
    log.trace "$ep: $cmd"

    def result = []
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	def text = "$device.displayName: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	result << createEvent(descriptionText: text, isStateChange: false)
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd, ep = null) {
    log.trace "$ep: $cmd"
    
    def events = []
    
    if (isHeatItZTRM2fx()) {
        events << processHeatItZTRM2fxConfigReport(cmd)
    } else if (isHeatItZTRM3()) {
        events << processHeatItZTRM3ConfigReport(cmd)
    }
    
    events?.flatten()
}

def zwaveEvent(physicalgraph.zwave.Command cmd, ep = null) {
    log.warn "$ep: Unexpected zwave command $cmd"
    []
}

// Update the setpoints ranges for SmartThings
private updateSetpointRanges() {
    sendEvent(name: "thermostatSetpointRange", value: [getTempInLocalScale(device.currentValue("minTemp") ?: MIN_HEATING_C, "C"), getTempInLocalScale(device.currentValue("maxTemp") ?: MAX_COOLING_C, "C")], displayed: false)
    sendEvent(name: "heatingSetpointRange", value: [getTempInLocalScale(device.currentValue("minTemp") ?: MIN_HEATING_C, "C"), getTempInLocalScale(device.currentValue("maxTemp") ?: MAX_HEATING_C, "C")], displayed: false)
    if (!isHeatItZTRM3()) {
        sendEvent(name: "coolingSetpointRange", value: [getTempInLocalScale(device.currentValue("minTemp") ?: MIN_COOLING_C, "C"), getTempInLocalScale(device.currentValue("maxTemp") ?: MAX_COOLING_C, "C")], displayed: false)
    }
}

private processHeatItZTRM3ConfigReport(cmd) {
    //log.trace "Processing HeatIt3 Config report"

    switch (cmd.parameterNumber) {
        case heatItParamMap3.sensorMode.Param:
        	switch (cmd.scaledConfigurationValue) {
            	case 0:
                	log.info "Floor sensor mode"
                    sendEvent(name: "sensorMode", value: "floor")
                	break
            	case 1:
                	log.info "Internal Room sensor mode"
                    sendEvent(name: "sensorMode", value: "internal")
                	break
            	case 2:
                	log.info "Internal both mode (internal room sensor with floor limitation)"
                    sendEvent(name: "sensorMode", value: "iboth")
                	break
            	case 3:
                	log.info "External room sensor mode"
                    sendEvent(name: "sensorMode", value: "room")
                	break
            	case 4:
                	log.info "Both mode (external room sensor with floor limitation)"
                    sendEvent(name: "sensorMode", value: "both")
                	break
            	default:
                	log.warn "Sensor mode unknown: ${cmd.configurationValue[0]}"
                	break
            }
            break
            
        case heatItParamMap3.display.Param:
        	switch (cmd.scaledConfigurationValue) {
            	case heatItParamMap3.display.Temperature:
                	log.info "Display mode: current temperature sensor"
                	sendEvent(name: "displayMode", value: "temperature")
                	break
            	case heatItParamMap3.display.Setpoint:
                	log.info "Display mode: current setpoint"
                    sendEvent(name: "displayMode", value: "setpoint")
                	break
            	default:
                	log.warn "Display mode unknown: ${cmd.configurationValue[0]}"
                	break
            }
            break
            
        case heatItParamMap3.hysteresis.Param:
            def msg = "Temperature control hysteresis: ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.fLo.Param:
            def msg = "Floor sensor minimum temperature limit ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            if ((device.currentValue("sensorMode") == "floor") || (device.currentValue("sensorMode") == "both") || (device.currentValue("sensorMode") == "iboth")) { // Both limits to floor temp
                sendEvent(name: "minTemp", value: ((cmd.scaledConfigurationValue as Float) / 10), displayed: false)
                updateSetpointRanges()
            }
            log.info msg
            break

        case heatItParamMap3.fHi.Param:
            def msg = "Floor sensor maximum temperature limit ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            if ((device.currentValue("sensorMode") == "floor") || (device.currentValue("sensorMode") == "both") || (device.currentValue("sensorMode") == "iboth")) { // Both limits to floor temp
                sendEvent(name: "maxTemp", value: ((cmd.scaledConfigurationValue as Float) / 10), displayed: false)
                updateSetpointRanges()
            }
            log.info msg
            break

        case heatItParamMap3.aLo.Param:
            def msg = "External room sensor minimum temperature limit ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            if (device.currentValue("sensorMode") == "room") {
                sendEvent(name: "minTemp", value: ((cmd.scaledConfigurationValue as Float) / 10), displayed: false)
                updateSetpointRanges()
            }
            log.info msg
            break

        case heatItParamMap3.aHi.Param:
            def msg = "External room sensor maximum temperature limit ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            if (device.currentValue("sensorMode") == "room") {
                sendEvent(name: "maxTemp", value: ((cmd.scaledConfigurationValue as Float) / 10), displayed: false)
                updateSetpointRanges()
            }
            log.info msg
            break

        case heatItParamMap3.fCal.Param:
            def msg = "Floor sensor calibration ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.aCal.Param:
            def msg = "External room sensor calibration ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.dimmedButtons.Param:
            def msg = "Button brightness (dimmed state) ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.activeButtons.Param:
            def msg = "Button brightness (active state) ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.dimmedDisplay.Param:
            def msg = "Display brightness (dimmed state) ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.activeDisplay.Param:
            def msg = "Display brightness (active state) ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.tempReporting.Param:
            def msg = "Temperature reporting interval ${cmd.scaledConfigurationValue} seconds"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.tempHysteresis.Param:
            def msg = "Temperature reporting hysteresis ${(cmd.scaledConfigurationValue as Float) / 10}°C"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.meterReporting.Param:
            def msg = "Meter reporting interval ${cmd.scaledConfigurationValue} seconds"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap3.meterSensitivity.Param:
            def msg = "Meter reporting kWH delta ${(cmd.scaledConfigurationValue as Float) / 10} kWH"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        default:
            def msg = "Unknown configuration parameter: $cmd"
            log.warn msg
            break    
    }

    [] // No events to return
}

private processHeatItZTRM2fxConfigReport(cmd) {
    //log.trace "Processing HeatIt2fx Config report"

    switch (cmd.parameterNumber) {
        case heatItParamMap.sensorMode.Param:
        	switch (cmd.scaledConfigurationValue) {
            	case 0:
                	log.info "Floor sensor mode"
                    sendEvent(name: "sensorMode", value: "floor")
                	break
            	case 3:
                	log.info "External room sensor mode"
                    sendEvent(name: "sensorMode", value: "room")
                	break
            	case 4:
                	log.info "Both mode (external room sensor with floor limitation)"
                    sendEvent(name: "sensorMode", value: "both")
                	break
            	default:
                	log.warn "Sensor mode unknown: ${cmd.configurationValue[0]}"
                	break
            }
            break
            
        case heatItParamMap.ecoSetpoint.Param:
        	if (device.currentValue("thermostatMode") == "eco") { // If we're in eco mode then update the heating setpoint
                def valC = cmd.scaledConfigurationValue/10.0 // Always reported in C, convert to F
                def cmdScale = "C"
                def setpoint = getTempInLocalScale(valC, cmdScale)
                def unit = getTemperatureScale()
                sendEvent(name: "heatingSetpoint", value: setpoint, unit: unit, displayed: false)
                updateThermostatSetpoint("heatingSetpoint", setpoint)
                log.info "Thermostat in Eco mode, updating heating setpoint ${valC}°C => ${setpoint}°${unit}"
            } else {
                log.debug "Thermostat not in Eco mode, ignoring eco setpoint: ${cmd.scaledConfigurationValue/10.0}"
            }
            break
        
        case heatItParamMap.display.Param:
        	switch (cmd.scaledConfigurationValue) {
            	case heatItParamMap.display.Temperature:
                	log.info "Display mode: current temperature sensor"
                	sendEvent(name: "displayMode", value: "temperature")
                	break
            	case heatItParamMap.display.Setpoint:
                	log.info "Display mode: current setpoint"
                    sendEvent(name: "displayMode", value: "setpoint")
                	break
            	default:
                	log.warn "Display mode unknown: ${cmd.configurationValue[0]}"
                	break
            }
            break
            
        case heatItParamMap.hysteresis.Param:
            def msg = "Temperature control hysteresis: ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.fLo.Param:
            def msg = "Floor sensor minimum temperature limit ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            if ((device.currentValue("sensorMode") == "floor") || (device.currentValue("sensorMode") == "both")) { // Both limits to floor temp
                sendEvent(name: "minTemp", value: ((cmd.scaledConfigurationValue as Float) / 10), displayed: false)
                updateSetpointRanges()
            }
            log.info msg
            break

        case heatItParamMap.fHi.Param:
            def msg = "Floor sensor maximum temperature limit ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            if ((device.currentValue("sensorMode") == "floor") || (device.currentValue("sensorMode") == "both")) { // Both limits to floor temp
                sendEvent(name: "maxTemp", value: ((cmd.scaledConfigurationValue as Float) / 10), displayed: false)
                updateSetpointRanges()
            }
            log.info msg
            break

        case heatItParamMap.aLo.Param:
            def msg = "External room sensor minimum temperature limit ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            if (device.currentValue("sensorMode") == "room") {
                sendEvent(name: "minTemp", value: ((cmd.scaledConfigurationValue as Float) / 10), displayed: false)
                updateSetpointRanges()
            }
            log.info msg
            break

        case heatItParamMap.aHi.Param:
            def msg = "External room sensor maximum temperature limit ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            if (device.currentValue("sensorMode") == "room") {
                sendEvent(name: "maxTemp", value: ((cmd.scaledConfigurationValue as Float) / 10), displayed: false)
                updateSetpointRanges()
            }
            log.info msg
            break

        case heatItParamMap.fCal.Param:
            def msg = "Floor sensor calibration ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.aCal.Param:
            def msg = "External room sensor calibration ${(cmd.scaledConfigurationValue as Float) / 10}°C" // Increments of 0.1°F
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.dimmedButtons.Param:
            def msg = "Button brightness (dimmed state) ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.activeButtons.Param:
            def msg = "Button brightness (active state) ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.dimmedDisplay.Param:
            def msg = "Display brightness (dimmed state) ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.activeDisplay.Param:
            def msg = "Display brightness (active state) ${cmd.scaledConfigurationValue}%"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.tempReporting.Param:
            def msg = "Temperature reporting interval ${cmd.scaledConfigurationValue} seconds"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.tempHysteresis.Param:
            def msg = "Temperature reporting hysteresis ${(cmd.scaledConfigurationValue as Float) / 10}°C"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.meterReporting.Param:
            def msg = "Meter reporting interval ${cmd.scaledConfigurationValue} seconds"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        case heatItParamMap.meterSensitivity.Param:
            def msg = "Meter reporting kWH delta ${(cmd.scaledConfigurationValue as Float) / 10} kWH"
            sendEvent(descriptionText: msg, displayed: true)
            log.info msg
            break

        default:
            def msg = "Unknown configuration parameter: $cmd"
            log.warn msg
            break    
    }

    [] // No events to return
}

// Configuration
def setConfigParameters() {
    def cmds = []

    if (isHeatItZTRM2fx()) {
        cmds += configureHeatItZTRMx(heatItParamMap, "getHeatItParamMap")
    } else if (isHeatItZTRM3()) {
        cmds += configureHeatItZTRMx(heatItParamMap3, "getHeatItParamMap3")
    }

    cmds ? secureSequence(cmds, 1500) : []
}

private configureHeatItZTRMx(heatItParam, heatItParamMapFunc) {
    def cmds = []
    def paramValues = []

    log.debug "Setting sensor mode to ${(sensorSelector as Integer) == null ? heatItParam.sensorMode.Default : (sensorSelector as Integer)}"
    cmds << zwave.configurationV2.configurationSet(parameterNumber: heatItParam.sensorMode.Param, size: heatItParam.sensorMode.Size, configurationValue: "${heatItParamMapFunc}"((sensorSelector as Integer) == null ? heatItParam.sensorMode.Default : (sensorSelector as Integer)).sensorMode.ParamValue)
    cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.sensorMode.Param) // Verify after
    
    log.debug "Setting temperature control hysteresis to ${(swingDiff == null) ? heatItParam.hysteresis.Default : ((swingDiff * 10) as Integer)}"
    cmds << zwave.configurationV2.configurationSet(parameterNumber: heatItParam.hysteresis.Param, size: heatItParam.hysteresis.Size, configurationValue: "${heatItParamMapFunc}"((swingDiff == null) ? heatItParam.hysteresis.Default : ((swingDiff * 10) as Integer)).hysteresis.ParamValue)
    cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.hysteresis.Param) // Verify after

    log.debug "Setting temperature reporting sensitivity to ${tempHysteresis ?: 0.5} °C" // 0.1C causes excessive reporting
    cmds << zwave.configurationV2.configurationSet(parameterNumber: heatItParam.tempHysteresis.Param, size: heatItParam.tempHysteresis.Size, configurationValue: "${heatItParamMapFunc}"(((tempHysteresis ?: 0.5) * 10) as Integer).tempHysteresis.ParamValue)
    cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.tempHysteresis.Param) // Verify after

    def mrv = ((meterReporting > 0) && (meterReporting < 30)) ? 30 : (meterReporting == null ? (zwaveInfo?.ver == "3.04" ? 0 : 180) : (meterReporting ?: (isHeatItZTRM3() ? 32767 : 0))) // Default, disable for 3.4 firmware otherwise 180 seconds (too much traffic causes the device to hang), Z-TRM3 does not support 0
    log.debug "Setting meter reporting frequency to $mrv seconds"
    cmds << zwave.configurationV2.configurationSet(parameterNumber: heatItParam.meterReporting.Param, size: heatItParam.meterReporting.Size, configurationValue: "${heatItParamMapFunc}"(mrv).meterReporting.ParamValue)
    cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.meterReporting.Param) // Verify after
    
    def trv = ((tempReporting > 0) && (tempReporting < 30)) ? 30 : (tempReporting == null ? (zwaveInfo?.ver == "3.04" ? 0 : 300) : (tempReporting ?: (isHeatItZTRM3() ? 32767 : 0))) // Default, disable for 3.4 firmware otherwise 300 seconds (too much traffic causes the device to hang), Z-TRM3 does not support 0
    log.debug "Setting temperature reporting frequency to $trv seconds"
    cmds << zwave.configurationV2.configurationSet(parameterNumber: heatItParam.tempReporting.Param, size: heatItParam.tempReporting.Size, configurationValue: "${heatItParamMapFunc}"(trv).tempReporting.ParamValue)
    cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.tempReporting.Param) // Verify after
    
    def mrdv = (isHeatItZTRM2fx() && (meterSensitivity > 127)) ? 127 : (meterSensitivity == null ? heatItParam.meterSensitivity.Default : meterSensitivity) // Z-TRM2fx only supports upto 127
    log.debug "Setting meter energy reporting delta (sensitivity) to $mrdv kWh"
    cmds << zwave.configurationV2.configurationSet(parameterNumber: heatItParam.meterSensitivity.Param, size: heatItParam.meterSensitivity.Size, configurationValue: "${heatItParamMapFunc}"(mrdv).meterSensitivity.ParamValue)
    cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.meterSensitivity.Param) // Verify after

    paramValues = [] // Reset it
    ["fCal", "aCal"].each {
        paramValues += ((settings."$it" == null) ? heatItParam."$it".Default : ((settings."$it" * 10) as Integer)) // Bulk set needs the actual data values, it'll convert to a byte array according to the size specified automatically
    }
    log.debug "Setting sensor calibrations: ${paramValues}"
    cmds << zwave.configurationV2.configurationBulkSet(handshake: true, numberOfParameters: paramValues.size(), parameterOffset: heatItParam.fCal.Param, size: heatItParam.fCal.Size, values: paramValues) // Set the parameters in bulk to avoid zwave issues

    paramValues = [] // Reset it
    ["fLo", "fHi", "aLo", "aHi"].each {
        paramValues += ((settings."$it" == null) ? heatItParam."$it".Default : ((settings."$it" * 10) as Integer)) // Bulk set needs the actual data values, it'll convert to a byte array according to the size specified automatically
    }
    log.debug "Setting 4 temperature limits: ${paramValues}"
    cmds << zwave.configurationV2.configurationBulkSet(handshake: true, numberOfParameters: paramValues.size(), parameterOffset: heatItParam.fLo.Param, size: heatItParam.fLo.Size, values: paramValues) // Set the parameters in bulk to avoid zwave issues

    paramValues = [] // Reset it
    ["dimmedButtons", "activeButtons", "dimmedDisplay", "activeDisplay"].each {
        paramValues += ((settings."$it" == null) ? heatItParam."$it".Default : (settings."$it" as Integer)) // Bulk set needs the actual data values, it'll convert to a byte array according to the size specified automatically
    }
    log.debug "Setting 4 brightness levels: ${paramValues}"
    cmds << zwave.configurationV2.configurationBulkSet(handshake: true, numberOfParameters: paramValues.size(), parameterOffset: heatItParam.dimmedButtons.Param, size: heatItParam.dimmedButtons.Size, values: paramValues) // Set the parameters in bulk to avoid zwave issues

    // TODO: Once handbrake (bulkReport) starts working, get rid of this individual get calls
    ["fCal", "aCal", "fLo", "fHi", "aLo", "aHi", "dimmedButtons", "activeButtons", "dimmedDisplay", "activeDisplay"].each {
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam."$it".Param) // Verify after
    }
    
    return cmds
}

// Command Implementations
def configure() {
    log.trace "Configure called"

    runIn(60, refresh) // Give it some time and then run refresh
    
    def cmds = []
    
    //cmds += discoverConfigParameters(), // DEBUGGING

    // TEST
    /*cmds += [
        secure(zwave.associationV1.associationGroupingsGet()),
        (1..4).collectMany {[ // 4 Association Groups
			secure(zwave.associationV1.associationGet(groupingIdentifier: it)),
			//secure(zwave.associationGrpInfoV1.associationGroupNameGet(groupingIdentifier: it)), - dead
			//secure(zwave.associationGrpInfoV1.associationGroupCommandListGet(groupingIdentifier: it, allowCache: false)), - dead
		]},
		//secure(zwave.associationGrpInfoV1.associationGroupInfoGet(listMode: true)), - dead
        secure(zwave.multiChannelAssociationV2.multiChannelAssociationGroupingsGet()),
        (1..4).collectMany {[ // 4 Multi Channel Groups
        	secure(zwave.multiChannelAssociationV2.multiChannelAssociationGet(groupingIdentifier: it)),
		]},
		secure(zwave.multiChannelV3.multiChannelEndPointGet()),
        (1..5).collectMany {[ // 5 Endpoints
			secure(zwave.multiChannelV3.multiChannelCapabilityGet(endPoint: it)),
		]},
        secure(zwave.multiChannelAssociationV2.multiChannelAssociationRemove(groupingIdentifier: 0)), // Remove all multi channel associations for all groups and endpoints
        secure(zwave.multiChannelAssociationV2.multiChannelAssociationSet(groupingIdentifier: 1, nodeId: [0,zwaveHubNodeId,1])), // Send all reports using multi channel reports to the hub on endpoint 1 (format -> [list of nodes to receive regular reports, 0, node x, endpoint on node x to receive encapsulated report, x1, endpoint on x1,...] -> here we want to regular reports, only encapsulated reports to be received by the hub on endpoint 1)
    ].flatten()*/

    // Setup multi channel associations for endpoints
    cmds += [
        //secure(zwave.associationV1.associationGet()),
        //(1..4).collectMany {[ // 4 Multi Channel Groups
        //	secure(zwave.multiChannelAssociationV2.multiChannelAssociationGet(groupingIdentifier: it)),
        //]},
        secure(zwave.multiChannelAssociationV2.multiChannelAssociationRemove(groupingIdentifier: 0)), // Remove all multi channel associations for all groups
        secure(zwave.multiChannelAssociationV2.multiChannelAssociationSet(groupingIdentifier: 1, nodeId: [0,zwaveHubNodeId,1])), // Send all reports using multi channel reports to the hub on endpoint 1 (format -> [list of nodes to receive regular reports, 0, node x, endpoint on node x to receive encapsulated report, x1, endpoint on x1,...] -> here we want to regular reports, only encapsulated reports to be received by the hub on endpoint 1)
        secure(zwave.multiChannelAssociationV2.multiChannelAssociationGet(groupingIdentifier: 1)),
    ]

    // Identify and configure the thermostat
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        cmds += [
            zwave.manufacturerSpecificV2.manufacturerSpecificGet().format(),
            //zwave.versionV1.versionGet().format(),
        ]
    } else {
        log.trace "Device MSR: $state.MSR"
    }

    cmds = delayBetween(cmds, 1000) + "delay 1000" + setConfigParameters()
    cmds
}

def refresh() {
    // Force a refresh
    log.debug "Requested a refresh\n${zwaveInfo?.inspect()}"

    def cmds = []
    
    if (!device.currentValue("thermostatSetpointRange")) {
        updateSetpointRanges()
    }

    // Identify and configure the thermostat
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        cmds << delayBetween([
            zwave.manufacturerSpecificV2.manufacturerSpecificGet().format(),
            zwave.versionV1.versionGet().format(),
        ], 2100)
    } else {
        log.trace "Device MSR: $state.MSR"
    }

    cmds << secureSequence([
        zwave.thermostatModeV2.thermostatModeSupportedGet(),
        zwave.thermostatModeV2.thermostatModeGet(),
        //zwave.sensorMultilevelV5.sensorMultilevelGet(), // current temperature
        (isHeatItZTRM2fx() || isHeatItZTRM2()) ? encap(zwave.switchBinaryV1.switchBinaryGet(), thermostatSwitchEp) : zwave.thermostatOperatingStateV1.thermostatOperatingStateGet(), // HeatIt - 4th endpoint is relay (operating state) - don't use basicGet since HeatIt has a bug where it spuriously sends a BasicReport (255) even when it's not operating
        // 1st endpoint is thermostat but we can use this as it's the only thermostat endpoint in the device
        zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: (device.currentValue("thermostatMode") == "eco" ? 11 : 1)), // HEAT, if we're in eco mode then read from settings
        zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 2), // COOL
        getSensors(), // Temp Sensors
        getControls(), // Controls, display, config etc
        getMetering(), // KWh, V, A W etc
    ].flatten(), 2300)

    sendHubCommand(response(cmds).toHubAction()) // Send command since this can be called from a schedule
}

// CHILD INTERFACES
def refreshChild() {
    log.trace "Refresh by child called"

    def cmds = []

    cmds << secureSequence([
        getSensors(), // Temp Sensors
    ].flatten(), 2300)

    cmds
}
// END

def levelUp() {
    log.trace "Level Up called"
    levelUpDown(1)
}

def levelDown() {
    log.trace "Level Down called"
    levelUpDown(-1)
}

def levelUpDown(value) {
    log.trace "levelUpDown called with value $value, current thermostat mode ${device.currentState("thermostatMode")?.value}"

    // NOTE: Bug in ST platform, for iOS devices we only get 0 (down) and 1 (up) for this control
    // For Android devices we get an absolute number showing the number of times up/down have been called since the page was opened (e.g. called up 4 times we get +4, if down then we get +3). If you open the page again and press up you get +1, if you close and open again and press down you get -1 (and the as long as the page is open it will be cumulative)

    // Determine which OS based on value behaviors (urrgghhh.....ST!)
    def upLevel
    if (!state.lastLevelUpDown)
    state.lastLevelUpDown = 0 // If it isn't defined lets baseline it

    if ((state.lastLevelUpDown == 1) && (value == 1)) // Last time it was 1 and again it's 1 its increase
    upLevel = true
    else if ((state.lastLevelUpDown == 0) && (value == 0)) // Last time it was 0 and again it's 0 then it's decrease
        upLevel = false
    else if ((state.lastLevelUpDown == -1) && (value == -1)) // Last time it was -1 and again it's -1 then it's decrease
        upLevel = false
    else if ((value - state.lastLevelUpDown) > 0) // If it's increasing then it's up
        upLevel = true
    else if ((value - state.lastLevelUpDown) < 0) // If it's decreasing then it's down
        upLevel = false
    else
        log.error "UNDEFINED STATE, CONTACT DEVELOPER. Last level $state.lastLevelUpDown, Current level, $value"

    state.lastLevelUpDown = value // Save it

    if (upLevel) { // Increase the current temperature (check heating or cooling mode)
        log.debug "Increasing temperature"
        if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
            delayBetween([raiseHeatingSetpoint(), raiseCoolSetpoint()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
            raiseHeatingSetpoint()
        } else if (device.currentState("thermostatMode")?.value.contains("eco")) { // HeatIt eco mode is heat
            raiseHeatingSetpoint()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
            raiseCoolSetpoint()
        }
    } else {
        log.debug "Reducing temperature"
        if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
            delayBetween([lowerHeatingSetpoint(), lowerCoolSetpoint()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
            lowerHeatingSetpoint()
        } else if (device.currentState("thermostatMode")?.value.contains("eco")) { // HeatIt eco mode is heat
            lowerHeatingSetpoint()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
            lowerCoolSetpoint()
        }
    }

    // NOTHING AFTER THE COMMANDS OR THE COMMANDS WONT WORK
}

def raiseHeatingSetpoint() {
    log.debug "Setting heat set point up"
	alterSetpoint(true, "heatingSetpoint")
}

def lowerHeatingSetpoint() {
    log.debug "Setting heat set point down"
	alterSetpoint(false, "heatingSetpoint")
}

def raiseCoolSetpoint() {
    if (!isHeatItZTRM3()) {
        log.debug "Setting cool set point up"
        alterSetpoint(true, "coolingSetpoint")
    }
}

def lowerCoolSetpoint() {
    if (!isHeatItZTRM3()) {
        log.debug "Setting cool set point down"
        alterSetpoint(false, "coolingSetpoint")
    }
}

// Adjusts nextHeatingSetpoint either .5° C/1° F) if raise true/false
def alterSetpoint(raise, setpoint) {
	def locationScale = getTemperatureScale()
	def deviceScale = (state.scale == 1) ? "F" : "C"
	def heatingSetpoint = getTempInLocalScale("heatingSetpoint")
	def coolingSetpoint = getTempInLocalScale("coolingSetpoint")
	def targetValue = (setpoint == "heatingSetpoint") ? heatingSetpoint : coolingSetpoint
	def delta = (locationScale == "F") ? 1 : 0.5
	targetValue += raise ? delta : - delta

	def data = enforceSetpointLimits(setpoint, [targetValue: targetValue, heatingSetpoint: heatingSetpoint, coolingSetpoint: coolingSetpoint])
	// update UI without waiting for the device to respond, this to give user a smoother UI experience
	// also, as runIn's have to overwrite and user can change heating/cooling setpoint separately separate runIn's have to be used
	if (data.targetHeatingSetpoint) {
		sendEvent("name": "heatingSetpoint", "value": getTempInLocalScale(data.targetHeatingSetpoint, deviceScale),
				unit: getTemperatureScale(), eventType: "ENTITY_UPDATE", displayed: false)
	}
	if (data.targetCoolingSetpoint) {
		sendEvent("name": "coolingSetpoint", "value": getTempInLocalScale(data.targetCoolingSetpoint, deviceScale),
				unit: getTemperatureScale(), eventType: "ENTITY_UPDATE", displayed: false)
	}
	if (data.targetHeatingSetpoint && data.targetCoolingSetpoint) {
		runIn(2, "updateHeatingSetpoint", [data: data, overwrite: true])
	} else if (setpoint == "heatingSetpoint" && data.targetHeatingSetpoint) {
		runIn(2, "updateHeatingSetpoint", [data: data, overwrite: true])
	} else if (setpoint == "coolingSetpoint" && data.targetCoolingSetpoint) {
		runIn(2, "updateCoolingSetpoint", [data: data, overwrite: true])
	}
}

def updateHeatingSetpoint(data) {
	updateSetpoints(data)
}

def updateCoolingSetpoint(data) {
    if (!isHeatItZTRM3()) {
        updateSetpoints(data)
    }
}

def enforceSetpointLimits(setpoint, data) {
	def locationScale = getTemperatureScale() 
	def minSetpoint = (setpoint == "heatingSetpoint") ? getTempInDeviceScale(device.currentValue("minTemp") ?: MIN_HEATING_C, "C") : getTempInDeviceScale(device.currentValue("minTemp") ?: MIN_COOLING_C, "C")
	def maxSetpoint = (setpoint == "heatingSetpoint") ? getTempInDeviceScale(device.currentValue("maxTemp") ?: MAX_HEATING_C, "C") : getTempInDeviceScale(device.currentValue("maxTemp") ?: MAX_COOLING_C, "C")
	def targetValue = getTempInDeviceScale(data.targetValue, locationScale)
	def heatingSetpoint = null
	def coolingSetpoint = null
	// Enforce min/mix for setpoints
	if (targetValue > maxSetpoint) {
		targetValue = maxSetpoint
	} else if (targetValue < minSetpoint) {
		targetValue = minSetpoint
	}
	if (setpoint == "heatingSetpoint") {
		heatingSetpoint = targetValue 
	}
	if (setpoint == "coolingSetpoint") {
		coolingSetpoint = targetValue
	}
    log.trace "Enforcing limits in °${locationScale} for request ${targetValue} ${setpoint}. Adjusted Settings -> ${heatingSetpoint ? "Heat: ${heatingSetpoint}" : ""} ${coolingSetpoint ? "Cool: ${coolingSetpoint}" : ""}"
	return [targetHeatingSetpoint: heatingSetpoint, targetCoolingSetpoint: coolingSetpoint]
}

def setHeatingSetpoint(degrees) {
	if (degrees) {
		state.heatingSetpoint = degrees.toDouble()
		runIn(2, "updateSetpoints", [overwrite: true])
	}
}

def setCoolingSetpoint(degrees) {
    if (!isHeatItZTRM3()) {
        if (degrees) {
            state.coolingSetpoint = degrees.toDouble()
            runIn(2, "updateSetpoints", [overwrite: true])
        }
    }
}

def updateSetpoints() {
	def deviceScale = (state.scale == 1) ? "F" : "C"
	def data = [targetHeatingSetpoint: null, targetCoolingSetpoint: null]
	def heatingSetpoint = getTempInLocalScale("heatingSetpoint")
	def coolingSetpoint = getTempInLocalScale("coolingSetpoint")
	if (state.heatingSetpoint) {
		data = enforceSetpointLimits("heatingSetpoint", [targetValue: state.heatingSetpoint,
				heatingSetpoint: heatingSetpoint, coolingSetpoint: coolingSetpoint])
	}
	if (state.coolingSetpoint) {
		heatingSetpoint = data.targetHeatingSetpoint ? getTempInLocalScale(data.targetHeatingSetpoint, deviceScale) : heatingSetpoint
		coolingSetpoint = data.targetCoolingSetpoint ? getTempInLocalScale(data.targetCoolingSetpoint, deviceScale) : coolingSetpoint
		data = enforceSetpointLimits("coolingSetpoint", [targetValue: state.coolingSetpoint,
				heatingSetpoint: heatingSetpoint, coolingSetpoint: coolingSetpoint])
		data.targetHeatingSetpoint =  data.targetHeatingSetpoint ?: (state.heatingSetpoint ? getTempInDeviceScale(heatingSetpoint, getTemperatureScale()) : null)
	}
	state.heatingSetpoint = null
	state.coolingSetpoint = null
	updateSetpoints(data)
}

def updateSetpoints(data) {
    log.debug "Setting setpoints: $data"
	def cmds = []
	if (data.targetHeatingSetpoint) {
        if (isHeatItZTRM3()) { // Bug in ZTRM3 firmware, does not accept heating setpoint below 13C via thermostatSetpointSet because the platform returns a 1 byte array and the Z-TRM3 only accepts a 2 byte array
            cmds << new physicalgraph.device.HubAction(secure(zwave.configurationV2.configurationSet(parameterNumber: heatItParamMap3.heatSetpoint.Param, size: heatItParamMap3.heatSetpoint.Size, configurationValue: getHeatItParamMap3((data.targetHeatingSetpoint * 10) as int).heatSetpoint.ParamValue))) // Heat - if we're in eco mode then update the eco heat configuration
        } else {
            cmds << new physicalgraph.device.HubAction(secure(zwave.thermostatSetpointV2.thermostatSetpointSet(setpointType: (device.currentValue("thermostatMode") == "eco" ? 11 : 1), scale: state.scale, precision: state.precision, scaledValue: data.targetHeatingSetpoint))) // If we're in eco mode then set the eco heat setpoint
        }
    }
	if (data.targetCoolingSetpoint) {
		cmds << new physicalgraph.device.HubAction(secure(zwave.thermostatSetpointV2.thermostatSetpointSet(setpointType: 2, scale: state.scale, precision: state.precision, scaledValue: data.targetCoolingSetpoint)))
	}
    cmds << new physicalgraph.device.HubAction(secure(zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: (device.currentValue("thermostatMode") == "eco" ? 11 : 1)))) // Heat - if we're in eco mode then update the eco heat configuration
    cmds << new physicalgraph.device.HubAction(secure(zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 2))) // Cool
    cmds << new physicalgraph.device.HubAction(secure((isHeatItZTRM2fx() || isHeatItZTRM2()) ? encap(zwave.switchBinaryV1.switchBinaryGet(), thermostatSwitchEp) : zwave.thermostatOperatingStateV1.thermostatOperatingStateGet())) // Doesn't support thermostatOperatingState

	sendHubCommand(delayBetween(cmds, 1300))
}

// thermostatSetpoint is not displayed by any tile as it can't be predictable calculated due to
// the device's quirkiness but it is defined by the capability so it must be set, set it to the most likely value
def updateThermostatSetpoint(setpoint, value) {
	def scale = getTemperatureScale()
	def heatingSetpoint = (setpoint == "heatingSetpoint") ? value : getTempInLocalScale("heatingSetpoint")
	def coolingSetpoint = (setpoint == "coolingSetpoint") ? value : getTempInLocalScale("coolingSetpoint")
	def mode = device.currentValue("thermostatMode")
	def thermostatSetpoint = heatingSetpoint    // corresponds to (mode == "heat" || mode == "emergency heat") || mode == "eco", for HeatIt eco is heating
	if (mode == "cool") {
		thermostatSetpoint = coolingSetpoint
	} else if (mode == "auto" || mode == "off") {
		// Set thermostatSetpoint to the setpoint closest to the current temperature
		def currentTemperature = getTempInLocalScale("temperature")
		if (currentTemperature > (heatingSetpoint + coolingSetpoint)/2) {
			thermostatSetpoint = coolingSetpoint
		}
	}
	sendEvent(name: "thermostatSetpoint", value: thermostatSetpoint, unit: getTemperatureScale())
}

def switchMode() {
	def currentMode = device.currentValue("thermostatMode")
	def supportedModes = state.supportedModes
	// Old version of supportedModes was as string, make sure it gets updated
	if (supportedModes && supportedModes.size() && supportedModes[0].size() > 1) {
		def next = { supportedModes[supportedModes.indexOf(it) + 1] ?: supportedModes[0] }
		def nextMode = next(currentMode)
		runIn(0, "setGetThermostatMode", [data: [nextMode: nextMode], overwrite: true])
	} else {
		log.warn "supportedModes not defined"
		getSupportedModes()
	}
}

def switchToMode(nextMode) {
	def supportedModes = state.supportedModes
	// Old version of supportedModes was as string, make sure it gets updated
	if (supportedModes && supportedModes.size() && supportedModes[0].size() > 1) {
		if (supportedModes.contains(nextMode)) {
			runIn(0, "setGetThermostatMode", [data: [nextMode: nextMode], overwrite: true])
		} else {
			log.debug("ThermostatMode $nextMode is not supported by ${device.displayName}")
		}
	} else {
		log.warn "supportedModes not defined"
		getSupportedModes()
	}
}

def getSupportedModes() {
	def cmds = []
	cmds << new physicalgraph.device.HubAction(secure(zwave.thermostatModeV2.thermostatModeSupportedGet()))
	sendHubCommand(cmds)
}

def getModeMap() { [
	"off": 0,
	"heat": 1,
	"cool": 2,
	"auto": 3,
	"emergency heat": 4,
    "eco": 11
]}

def setThermostatMode(String value) {
	switchToMode(value)
}

def setGetThermostatMode(data) {
    log.debug "Setting thermostat mode to ${data.nextMode}"
	def cmds = [
        new physicalgraph.device.HubAction(secure(zwave.thermostatModeV2.thermostatModeSet(mode: modeMap[data.nextMode]))),
        new physicalgraph.device.HubAction(secure(zwave.thermostatModeV2.thermostatModeGet())),
        new physicalgraph.device.HubAction(secure((isHeatItZTRM2fx() || isHeatItZTRM2()) ? encap(zwave.switchBinaryV1.switchBinaryGet(), thermostatSwitchEp) : zwave.thermostatOperatingStateV1.thermostatOperatingStateGet())) // Doesn't support thermostatOperatingState
    ]
	sendHubCommand(cmds)
}

def off() {
	switchToMode("off")
}

def heat() {
	switchToMode("heat")
}

def emergencyHeat() {
	switchToMode("emergency heat")
}

def cool() {
	switchToMode("cool")
}

def auto() {
	switchToMode("auto")
}

def setReset(delay = null) {
    log.trace "Resetting energy with delay $delay"
    resetEnergy()
}

def resetEnergy() {
    log.trace "Resetting energy"
    sendEvent(name: "resetEnergy", value: "resetting", isStateChange: true, descriptionText: "Resetting energy meter")
    runIn(RESET_DELAY, delayedEvent, [data: [name: "resetEnergy", value: "ready", isStateChange: true]])

    secureSequence([
		zwave.meterV3.meterReset(),
		zwave.meterV3.meterGet(scale: 0),
	])
}

// Get stored temperature from currentState in current local scale
def getTempInLocalScale(state) {
	def temp = device.currentState(state)
	if (temp && temp.value && temp.unit) {
		return getTempInLocalScale(temp.value.toBigDecimal(), temp.unit)
	}
	return 0
}

// get/convert temperature to current local scale
def getTempInLocalScale(temp, scale) {
	if (temp && scale) {
		def scaledTemp = convertTemperatureIfNeeded(temp.toBigDecimal(), scale).toDouble()
		return (getTemperatureScale() == "F" ? scaledTemp.round(0).toInteger() : roundC(scaledTemp))
	}
	return 0
}

def getTempInDeviceScale(state) {
	def temp = device.currentState(state)
	if (temp && temp.value && temp.unit) {
		return getTempInDeviceScale(temp.value.toBigDecimal(), temp.unit)
	}
	return 0
}

def getTempInDeviceScale(temp, scale) {
	if (temp && scale) {
		def deviceScale = (state.scale == 1) ? "F" : "C"
		return (deviceScale == scale) ? temp :
				(deviceScale == "F" ? celsiusToFahrenheit(temp).toDouble().round(0).toInteger() : roundC(fahrenheitToCelsius(temp)))
	}
	return 0
}

def roundC (tempC) {
	return (Math.round(tempC.toDouble() * 2))/2
}

def discoverConfigParameters() {
    log.trace "Discovering the first 15 configuration parameters"

    def cmds = []
    (1..30).each { param ->
        cmds << secure(zwave.configurationV2.configurationGet(parameterNumber: param)) // Check before
    }
    cmds
}

// Checks if it's a HeatIt thermostat
private isHeatIt() {
    (state.MSR?.startsWith("019B") || ("019B" == zwaveInfo?.mfr)) ? true : false // If called from installed(), MSR may not exist yet
}

private isHeatItZTRM2() {
    (state.MSR?.startsWith("019B-0001-0001") || (("019B" == zwaveInfo?.mfr) && ("0001" == zwaveInfo?.prod) && ("0001" == zwaveInfo?.model))) ? true : false // If called from installed(), MSR may not exist yet
}

private isHeatItZTRM2fx() {
    (state.MSR?.startsWith("019B-0003-0202") || (("019B" == zwaveInfo?.mfr) && ("0003" == zwaveInfo?.prod) && ("0202" == zwaveInfo?.model))) ? true : false // If called from installed(), MSR may not exist yet
}

private isHeatItZTRM3() {
    (state.MSR?.startsWith("019B-0003-0203") || (("019B" == zwaveInfo?.mfr) && ("0003" == zwaveInfo?.prod) && ("0203" == zwaveInfo?.model))) ? true : false // If called from installed(), MSR may not exist yet
}

// Legacy for backward compatibility
def quickSetCool(degrees) {
    setCoolingSetpoint(degrees)
}

def quickSetHeat(degrees) {
    setHeatingSetpoint(degrees)
}

// Toggle diplay mode on physical device
def toggleDisplayMode() {
    log.trace "Toggling display mode"
    
    switch (device.currentValue("displayMode")) {
        case "temperature":
            return setDisplayMode("setpoint")
            break
        case "setpoint":
            return setDisplayMode("temperature")
            break
        default: // default is setpoint
            return setDisplayMode("setpoint")
	        break
    }
}

def setDisplaySetpoint() {
    log.trace "Set display setpoint"
    setDisplayMode("setpoint")
}

def setDisplayTemperature() {
    log.trace "Set display temperature"
    setDisplayMode("temperature")
}

def setDisplayMode(mode) {
    def cmds = []
    def heatItParam = isHeatItZTRM3() ? heatItParamMap3 : (isHeatItZTRM2fx() ? heatItParamMap : null)
    if (heatItParam) {
        def value
        switch (mode) {
            case "setpoint":
            	log.debug "Setting display mode to Setpoint"
                value = heatItParam.display.Setpoint
                break
            case "temperature":
            	log.debug "Setting display mode to Temperature"
                value = heatItParam.display.Temperature
                break
            default:
            	log.debug "Unknown, current display mode, setting to Setpoint"
                value = heatItParam.display.Setpoint
                break
        }
        cmds << zwave.configurationV2.configurationSet(parameterNumber: heatItParam.display.Param, size: heatItParam.display.Size, configurationValue: [ value ])
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.display.Param) // Verify after
    } else {
        log.warn "This device does not support display controls"
    }
    
    cmds ? secureSequence(cmds, 2000) : [] // This is called directly so return with delays
}

// Get Sensor readings
private getSensors() {
    def cmds = []
    
    if (isHeatIt()) {
        log.debug "Getting sensor readings"
        def tempSensors = [ roomSensorEp, floorSensorEp ] + (isHeatItZTRM3() ? internalSensorEp : [])
        tempSensors.each { sensorEp ->
            cmds += [
                encap(zwave.sensorMultilevelV5.sensorMultilevelGet(), sensorEp)
            ]
        }
    } else {
        log.trace "This device does not support sensors"
    }
    
    cmds
}

// Get meter readings
private getMetering() {
    def cmds = []
    
    cmds += [ // HeatIt does not support meterReset()
        zwave.meterV3.meterGet(scale: 0), // kWh
        zwave.meterV3.meterGet(scale: 2), // W
        zwave.meterV3.meterGet(scale: 4), // V
        zwave.meterV3.meterGet(scale: 5), // A
    ]
    
    cmds
}

// Get the status of controls of physical device
private getControls() {
    def cmds = []
    
    def heatItParam = isHeatItZTRM3() ? heatItParamMap3 : (isHeatItZTRM2fx() ? heatItParamMap : null)
    if (heatItParam) {
        log.debug "Getting status of controls"
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.display.Param)
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.sensorMode.Param)
        // TODO: When bulkReport starts working, replace this with bulk report
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.fLo.Param)
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.fHi.Param)
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.aLo.Param)
        cmds << zwave.configurationV2.configurationGet(parameterNumber: heatItParam.aHi.Param)
    } else {
        log.trace "This device does not support controls"
    }
    
    cmds
}

// Create child device for endpoints if not already created
private createChildDevices() {
    if (!childDevices) {
        try {
            def child
            state.oldLabel = device.displayName

            log.info "Adding child device floor temperature sensor"
            child = addChildDevice(
                "smartthings",
                "Child Temperature Sensor",
                "${device.deviceNetworkId}-ep${floorSensorEp}",
                device.hub.id,
                [
                    completedSetup: true,
                    label: "${device.displayName} (Floor Sensor)",
                    isComponent: true,
                    componentName: "FloorSensor",
                    componentLabel: "Floor Sensor"
                ]
            )
            child.sendEvent(name: "battery", value: 100)
            child.sendEvent(name: "DeviceWatch-Enroll", value: [protocol: "cloud", scheme:"untracked"].encodeAsJson(), displayed: false)

            log.info "Adding child device room temperature sensor"
            child = addChildDevice(
                "smartthings",
                "Child Temperature Sensor",
                "${device.deviceNetworkId}-ep${roomSensorEp}",
                device.hub.id,
                [
                    completedSetup: true,
                    label: "${device.displayName} (Room Sensor)",
                    isComponent: true,
                    componentName: "RoomSensor",
                    componentLabel: "Room Sensor"
                ]
            )
            child.sendEvent(name: "battery", value: 100)
            child.sendEvent(name: "DeviceWatch-Enroll", value: [protocol: "cloud", scheme:"untracked"].encodeAsJson(), displayed: false)

            if (isHeatItZTRM3()) {
                log.info "Adding child device internal temperature sensor"
                child = addChildDevice(
                    "smartthings",
                    "Child Temperature Sensor",
                    "${device.deviceNetworkId}-ep${internalSensorEp}",
                    device.hub.id,
                    [
                        completedSetup: true,
                        label: "${device.displayName} (Internal Sensor)",
                        isComponent: true,
                        componentName: "InternalSensor",
                        componentLabel: "Internal Sensor"
                    ]
                )
                child.sendEvent(name: "battery", value: 100)
                child.sendEvent(name: "DeviceWatch-Enroll", value: [protocol: "cloud", scheme:"untracked"].encodeAsJson(), displayed: false)
            }
        } catch(Exception e) {
            log.error "Unable to create child devices: ${e}"
        }
    } else if (device.displayName != state.oldLabel) { // If the user has updated the display name update, the child names
        childDevices.each {
            def newLabel = "${device.displayName} ${(it.label =~ /[^)][^(]*$/)[0]}" // Preserve the (xxx) at the end, just add the parent label
            log.debug "Setting $it name to $newLabel"
            it.setLabel(newLabel)
        }
        state.oldLabel = device.displayName
    }
}

// List of supported capabilities
private getCommandClassCapabilities() {
    [
        0x85:1, // Association
		0x59:1, // Association Group Info
		0x8E:2, // Multi Channel Association (supports v3)
        0x86:1, // Version (suppports v3)
        0x70:2, // Configuration (supports v3)
        0x72:2, // Manufacturer Specific
        0x60:3, // Multi Channel (supports v4)
        0x20:1, // Basic (supports v2)
        0x31:5, // Sensor Multilevel
        0x43:2, // Thermostat Setpoint (supports v3)
        0x40:2, // Thermostat Mode (supports v3)
        0x42:1, // Thermostat Operating State
        0x25:1, // Switch Binary
        0x32:3, // Meter
        0x98:1, // Security
        0x80:1, // Battery
    ]
}

private paramValue(value, bytes) {
    if (value == null || !(value instanceof Number)) {
        return null
    }
        
    //log.trace "Param value: $value, $bytes"

    List<Integer> ret = [] // We start with a Integer list and then convert to array (since arrays are fixed in size)
    for (int i=0; i<bytes; i++) {
        ret = [(((value as Long) >> (i*8)) & 0xFF) as Integer] + ret
    }
    
    //log.debug ret as Integer[]
    
    return ret as Integer[] // We need an integer array
}

private reverseValue(value) {
    if (!value || !List.isCase(value)) {
        return null
    }
        
    //log.trace "Reverse value: $value, $bytes"

    Long ret = 0
    for (int i=0; i<value.size(); i++) {
        ret |= ((((value[i] as Integer) & 0xFF) as Long) << ((value.size() - 1 - i) * 8)) as Long
    }
    
    //log.debug ret
    
    return ret
}

private getHeatItParamMap(value = null) {
	[
        "sensorMode":		[ Param: 2, Size: 1, Default: 0, Min: 0, Max: 4, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "hysteresis":		[ Param: 4, Size: 1, Default: 5, Min: 3, Max: 30, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "fLo":				[ Param: 5, Size: 2, Default: 50, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "fHi":				[ Param: 6, Size: 2, Default: 400, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "aLo":				[ Param: 7, Size: 2, Default: 50, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "aHi":				[ Param: 8, Size: 2, Default: 400, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ecoSetpoint":		[ Param: 10, Size: 2, Default: 18, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "fCal":				[ Param: 12, Size: 1, Default: 0, Min: -40, Max: 40, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "aCal":				[ Param: 13, Size: 1, Default: 0, Min: -40, Max: 40, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "display": 			[ Param: 14, Size: 1, Default: 0, Temperature: 1, Setpoint: 0 ],
        "dimmedButtons":	[ Param: 15, Size: 1, Default: 50, Min: 0, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "activeButtons":	[ Param: 16, Size: 1, Default: 100, Min: 0, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "dimmedDisplay":	[ Param: 17, Size: 1, Default: 50, Min: 0, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "activeDisplay":	[ Param: 18, Size: 1, Default: 100, Min: 0, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "tempReporting":	[ Param: 19, Size: 2, Default: 60, Min: 0, Max: 32767, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "tempHysteresis":	[ Param: 20, Size: 1, Default: 10, Min: 1, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "meterReporting":	[ Param: 21, Size: 2, Default: 60, Min: 0, Max: 32767, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "meterSensitivity":	[ Param: 22, Size: 1, Default: 10, Min: 0, Max: 127, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
	]
}

private getHeatItParamMap3(value = null) {
	[
        "sensorMode":		[ Param: 2, Size: 1, Default: 1, Min: 0, Max: 4, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "hysteresis":		[ Param: 4, Size: 1, Default: 5, Min: 3, Max: 30, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "fLo":				[ Param: 5, Size: 2, Default: 50, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "fHi":				[ Param: 6, Size: 2, Default: 400, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "aLo":				[ Param: 7, Size: 2, Default: 50, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "aHi":				[ Param: 8, Size: 2, Default: 400, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "heatSetpoint":		[ Param: 9, Size: 2, Default: 210, Min: 50, Max: 400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "rCal":				[ Param: 10, Size: 1, Default: 0, Min: -60, Max: 60, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "fCal":				[ Param: 11, Size: 1, Default: 0, Min: -60, Max: 60, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "aCal":				[ Param: 12, Size: 1, Default: 0, Min: -60, Max: 60, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "display": 			[ Param: 13, Size: 1, Default: 0, Temperature: 1, Setpoint: 0 ],
        "dimmedButtons":	[ Param: 14, Size: 1, Default: 50, Min: 0, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "activeButtons":	[ Param: 15, Size: 1, Default: 100, Min: 0, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "dimmedDisplay":	[ Param: 16, Size: 1, Default: 50, Min: 0, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "activeDisplay":	[ Param: 17, Size: 1, Default: 100, Min: 0, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "tempReporting":	[ Param: 18, Size: 2, Default: 60, Min: 0, Max: 32767, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "tempHysteresis":	[ Param: 19, Size: 1, Default: 10, Min: 1, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "meterReporting":	[ Param: 20, Size: 2, Default: 90, Min: 0, Max: 32767, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "meterSensitivity":	[ Param: 21, Size: 1, Default: 10, Min: 0, Max: 255, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
	]
}

// THIS IS THE END OF THE FILE